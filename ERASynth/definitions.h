/*
*
* Copyright (c) 2018 ERA Instruments (http://erainstruments.com/)

* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

// Make DEBUG = 1 to write faster when debugging. This will avoid amplitude calibration files to written in flash
#define DEBUG 0
#define ERASynth 0
#define max_DAC_Value 4095
#define min_DAC_Value 0
#define LMX1_LE 10
#define LMX2_LE 4
#define DDS_LE 52
#define LBand 0
#define MBand 1
#define UBand 2
#define OFFBand 3
#define maxSamplesNum 120
#define NBFM_Mod 0
#define WBFM_Mod 1
#define AM_Mod 2
#define Pulse_Mod 3
#define Internal 0
#define External 1
#define Microphone 2
#define Sine 0
#define Triangle 1
#define Ramp 2
#define Square 3
#define WREN  6
#define WRDI  4
#define RDSR  5
#define WRSR  1
#define READ  3
#define WRITE 2

#if ERASynth == 0
  #include "calibration_0.h"
#endif

#if ERASynth == 1 
  #include "calibration_1.h"
#endif
  
#if ERASynth == 2 
  #include "calibration_1.h"
  #include "calibration_2.h"  
#endif

static int sine_waveform[maxSamplesNum] = // Sine wave
{   
  0xfff, 0xffc, 0xff3, 0xfe5, 0xfd2, 0xfb9, 0xf9a, 0xf77, 0xf4d, 0xf1f,
  0xeec, 0xeb4, 0xe77, 0xe36, 0xdf1, 0xda7, 0xd59, 0xd08, 0xcb2, 0xc5a,
  0xbff, 0xba1, 0xb40, 0xadd, 0xa78, 0xa11, 0x9a9, 0x93f, 0x8d5, 0x86a,
  0x7ff, 0x794, 0x729, 0x6bf, 0x655, 0x5ed, 0x586, 0x521, 0x4be, 0x45d,
  0x3ff, 0x3a4, 0x34c, 0x2f6, 0x2a5, 0x257, 0x20d, 0x1c8, 0x187, 0x14a,
  0x112, 0xdf, 0xb1, 0x87, 0x64, 0x45, 0x2c, 0x19, 0xb, 0x2,
  0x0, 0x2, 0xb, 0x19, 0x2c, 0x45, 0x64, 0x87, 0xb1, 0xdf,
  0x112, 0x14a, 0x187, 0x1c8, 0x20d, 0x257, 0x2a5, 0x2f6, 0x34c, 0x3a4,
  0x3ff, 0x45d, 0x4be, 0x521, 0x586, 0x5ed, 0x655, 0x6bf, 0x729, 0x794,
  0x7ff, 0x86a, 0x8d5, 0x93f, 0x9a9, 0xa11, 0xa78, 0xadd, 0xb40, 0xba1,
  0xbff, 0xc5a, 0xcb2, 0xd08, 0xd59, 0xda7, 0xdf1, 0xe36, 0xe77, 0xeb4,
  0xeec, 0xf1f, 0xf4d, 0xf77, 0xf9a, 0xfb9, 0xfd2, 0xfe5, 0xff3, 0xffc
};

static int triangular_waveform[maxSamplesNum] = // Triangular wave
{   
  0x44, 0x88, 0xcc, 0x110, 0x154, 0x198, 0x1dc, 0x220, 0x264, 0x2a8,
  0x2ec, 0x330, 0x374, 0x3b8, 0x3fc, 0x440, 0x484, 0x4c8, 0x50c, 0x550,
  0x594, 0x5d8, 0x61c, 0x660, 0x6a4, 0x6e8, 0x72c, 0x770, 0x7b4, 0x7f8,
  0x83c, 0x880, 0x8c4, 0x908, 0x94c, 0x990, 0x9d4, 0xa18, 0xa5c, 0xaa0,
  0xae4, 0xb28, 0xb6c, 0xbb0, 0xbf4, 0xc38, 0xc7c, 0xcc0, 0xd04, 0xd48,
  0xd8c, 0xdd0, 0xe14, 0xe58, 0xe9c, 0xee0, 0xf24, 0xf68, 0xfac, 0xff0,
  0xfac, 0xf68, 0xf24, 0xee0, 0xe9c, 0xe58, 0xe14, 0xdd0, 0xd8c, 0xd48,
  0xd04, 0xcc0, 0xc7c, 0xc38, 0xbf4, 0xbb0, 0xb6c, 0xb28, 0xae4, 0xaa0,
  0xa5c, 0xa18, 0x9d4, 0x990, 0x94c, 0x908, 0x8c4, 0x880, 0x83c, 0x7f8,
  0x7b4, 0x770, 0x72c, 0x6e8, 0x6a4, 0x660, 0x61c, 0x5d8, 0x594, 0x550,
  0x50c, 0x4c8, 0x484, 0x440, 0x3fc, 0x3b8, 0x374, 0x330, 0x2ec, 0x2a8,
  0x264, 0x220, 0x1dc, 0x198, 0x154, 0x110, 0xcc, 0x88, 0x44, 0x0
};

static int ramp_waveform[maxSamplesNum] = // Ramp wave
{   
  0x22, 0x44, 0x66, 0x88, 0xaa, 0xcc, 0xee, 0x110, 0x132, 0x154,
  0x176, 0x198, 0x1ba, 0x1dc, 0x1fe, 0x220, 0x242, 0x264, 0x286, 0x2a8,
  0x2ca, 0x2ec, 0x30e, 0x330, 0x352, 0x374, 0x396, 0x3b8, 0x3da, 0x3fc,
  0x41e, 0x440, 0x462, 0x484, 0x4a6, 0x4c8, 0x4ea, 0x50c, 0x52e, 0x550,
  0x572, 0x594, 0x5b6, 0x5d8, 0x5fa, 0x61c, 0x63e, 0x660, 0x682, 0x6a4,
  0x6c6, 0x6e8, 0x70a, 0x72c, 0x74e, 0x770, 0x792, 0x7b4, 0x7d6, 0x7f8,
  0x81a, 0x83c, 0x85e, 0x880, 0x8a2, 0x8c4, 0x8e6, 0x908, 0x92a, 0x94c,
  0x96e, 0x990, 0x9b2, 0x9d4, 0x9f6, 0xa18, 0xa3a, 0xa5c, 0xa7e, 0xaa0,
  0xac2, 0xae4, 0xb06, 0xb28, 0xb4a, 0xb6c, 0xb8e, 0xbb0, 0xbd2, 0xbf4,
  0xc16, 0xc38, 0xc5a, 0xc7c, 0xc9e, 0xcc0, 0xce2, 0xd04, 0xd26, 0xd48,
  0xd6a, 0xd8c, 0xdae, 0xdd0, 0xdf2, 0xe14, 0xe36, 0xe58, 0xe7a, 0xe9c,
  0xebe, 0xee0, 0xf02, 0xf24, 0xf46, 0xf68, 0xf8a, 0xfac, 0xfce, 0xff0
};

static int square_waveform[maxSamplesNum] = // Square wave
{   
  0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};  
  
uint16_t address_start = 100;
uint8_t _freqSize = 11;

// First row is address, second row is size
uint16_t _ERASynthModel[]			= { 0, 1 };
uint16_t _serialNumber[]			= { _ERASynthModel[0] + _ERASynthModel[1] , 4 };
uint16_t _firmware[]				= { _serialNumber[0] + _serialNumber[1] , 32 };
uint16_t _frequency[]				= { address_start, _freqSize };
uint16_t _amplitude[]				= { _frequency[0] + _frequency[1], 6 };
uint16_t _startFrequency[]			= { _amplitude[0] + _amplitude[1], _freqSize };
uint16_t _stopFrequency[]			= { _startFrequency[0] + _startFrequency[1], _freqSize };
uint16_t _stepFrequency[]			= { _stopFrequency[0] + _stopFrequency[1], _freqSize };
uint16_t _dwellTime[]				= { _stepFrequency[0] + _stepFrequency[1], 5 };
uint16_t _rfOnOff[]					= { _dwellTime[0] + _dwellTime[1], 1 };
uint16_t _esp8266OnOff[]			= { _rfOnOff[0] + _rfOnOff[1] , 1 };
uint16_t _isLowPowerModeActive[]	= { _esp8266OnOff[0] + _esp8266OnOff[1] ,1 };
uint16_t _referenceIntOrExt[]		= { _isLowPowerModeActive[0] + _isLowPowerModeActive[1],1 };
uint16_t _referenceTcxoOrOcxo[]		= { _referenceIntOrExt[0] + _referenceIntOrExt[1] ,1 };
uint16_t _modulationType[]			= { _referenceTcxoOrOcxo[0] + _referenceTcxoOrOcxo[1],1 };
uint16_t _modulationSource[]		= { _modulationType[0] + _modulationType[1],1 };
uint16_t _internalModulationFreq[]	= { _modulationSource[0] + _modulationSource[1],5 };
uint16_t _fmDeviation[]				= { _internalModulationFreq[0] + _internalModulationFreq[1],7 };
uint16_t _amDepth[]					= { _fmDeviation[0] + _fmDeviation[1],3 };
uint16_t _modulationOnOff[]			= { _amDepth[0] + _amDepth[1],1 };
uint16_t _rememberLastStates[]		= { _modulationOnOff[0] + _modulationOnOff[1],1 };
uint16_t _isUploadCodeModeActive[]	= { _rememberLastStates[0] + _rememberLastStates[1],1 };
uint16_t _sweepTriggerMode[]		= { _isUploadCodeModeActive[0] + _isUploadCodeModeActive[1],1 };
uint16_t _sweepOnOff[]				= { _sweepTriggerMode[0] + _sweepTriggerMode[1],1 };
uint16_t _wifiMode[]				= { _sweepOnOff[0] + _sweepOnOff[1],1 };
uint16_t _pulsePeriod[]				= { _wifiMode[0] + _wifiMode[1],9 };
uint16_t _pulseWidth[]				= { _pulsePeriod[0] + _pulsePeriod[1],9 };
uint16_t _waveformType[]			= { _pulseWidth[0] + _pulseWidth[1],1 };
uint16_t _staModeSSID[]				= { _waveformType[0] + _waveformType[1],32 };
uint16_t _apModeSSID[]				= { _staModeSSID[0] + _staModeSSID[1],32 };
uint16_t _staModePassword[]			= { _apModeSSID[0] + _apModeSSID[1],64};
uint16_t _apModePassword[]			= { _staModePassword[0] + _staModePassword[1],64};
uint16_t _ipAddress[]				= { _apModePassword[0] + _apModePassword[1],15 };
uint16_t _gatewayAddress[]			= { _ipAddress[0] + _ipAddress[1],15 };
uint16_t _subnetAddress[]			= { _gatewayAddress[0] + _gatewayAddress[1],15 };
uint16_t _phaseNoise[]				= { _subnetAddress[0] + _subnetAddress[1], 1 };

uint8_t init_DDS_CFR1[5]		= {0x00, 0x00, 0x08, 0x00, 0x00};
uint8_t init_DDS_CFR2[3]		= {0x01, 0x14, 0x20};
uint8_t init_DDS_DAC[5]			= {0x02, 0x00, 0x7F, 0x10, 0x00};
uint8_t init_DDS_FTW[5]			= {0x03, 0x01, 0x00, 0x00, 0x00};
uint8_t DDS_FTW_update[5]		= {0x03, 0x01, 0x00, 0x00, 0x00};
uint8_t DDS_DAC_update[5]		= {0x02, 0x00, 0x7F, 0x10, 0xFF};
uint8_t DDS_CFR1_Pwr_Down[5]	= {0x00, 0x00, 0x08, 0x00, 0x70};


//ADF4002 Initialization
uint8_t init_ADF4002_Initialization[3]	= {0x20, 0x00, 0x93};
uint8_t init_ADF4002_Function[3]		= {0x20, 0x00, 0x92}; //CP Current=0.294 (11K)
uint8_t init_ADF4002_R_Counter[3]		= {0x10, 0x00, 0x04}; //RDiv=1
uint8_t init_ADF4002_N_Counter[3]		= {0x00, 0x0A, 0x01};

//LMX1 Initialization for DDS
uint32_t LMX1_R36_DDS = 0x240028;
uint32_t LMX1_R42_DDS = 0x2AABA9;
uint32_t LMX1_R43_DDS = 0x2B5000;
uint32_t LMX1_R75_DDS = 0x4B09C0;
uint32_t LMX1_R38_DDS = 0x26B2D0;
uint32_t LMX1_R39_DDS = 0x275E00;

//LMX1 Initialization
uint32_t LMX1_R36_update	= 0x24002B;
uint32_t LMX1_R38_update	= 0x26B2D0;
uint32_t LMX1_R39_update	= 0x275E00;
uint32_t LMX1_R40_update	= 0x280000;
uint32_t LMX1_R41_update	= 0x290000;
uint32_t LMX1_R42_update	= 0x2A004B;
uint32_t LMX1_R43_update	= 0x2B5A1C;
uint32_t LMX1_R75			= 0x4B0A40; //CHDIV = 64
uint32_t LMX1_R0_reset		= 0x00251E; // OUT_MUTE = 0
uint32_t LMX1_R0			= 0x00251C; // OUT_MUTE = 0
uint32_t LMX1_R0_mute		= 0x00251D;
uint32_t LMX1_register[113] = {
0x700000,
0x6F0000,
0x6E0000,
0x6D0000,
0x6C0000,
0x6B0000,
0x6A0000,
0x690021,
0x680000,
0x670000,
0x660000,
0x650011,
0x640000,
0x630000,
0x620000,
0x610888,
0x600000,
0x5F0000,
0x5E0000,
0x5D0000,
0x5C0000,
0x5B0000,
0x5A0000,
0x590000,
0x580000,
0x570000,
0x560000,
0x550000,
0x540000,
0x530000,
0x520000,
0x510000,
0x500000,
0x4F0000,
0x4E0003,
0x4D0000,
0x4C000C,
0x4B0A40, //CHDIV = 64
0x4A0000,
0x49003F,
0x480001,
0x470081,
0x46C350,
0x450000,
0x4403E8,
0x430000,
0x4201F4,
0x410000,
0x401388,
0x3F0000,
0x3E0322,
0x3D00A8,
0x3C0000,
0x3B0001,
0x3A8001,
0x390020,
0x380000,
0x370000,
0x360000,
0x350000,
0x340820,
0x330080,
0x320000,
0x314180,
0x300300,
0x2F0300,
0x2E07FC,
0x2DC0C0,
0x2C3FA3, // MASH_ORDER = 3 // output power level = 3F
0x2B5A1C,
0x2A004B,
0x290000,
0x280000,
0x275E00,
0x26B2D0,
0x258304, //PFD_DLY_SEL = 3
0x24002B,
0x230004,
0x220000,
0x211E21,
0x200393,
0x1F43EC,
0x1E318C,
0x1D318C,
0x1C0488,
0x1B0002,
0x1A0DB0,
0x190624,
0x18071A,
0x17007C,
0x160001,
0x150401,
0x14E048,
0x1327B7,
0x120064,
0x11012C,
0x100080,
0x0F064F,
0x0E1E40, //CP = 3mA
0x0D4000,
0x0C5001,
0x0B0018,
0x0A10D8,
0x091604, // OSC_2x = 1
0x082000, 
0x0740B2, // OUT_FORCE = 1
0x06C802,
0x0500C8,
0x040A43,
0x030642,
0x020500,
0x010808,
0x00251C //OUT_MUTE = 0
};

//LMX2 Initialization
uint32_t LMX2_R36_update	= 0x240030;
uint32_t LMX2_R37_update_2	= 0x250204; //PFD_DLY_SEL = 2
uint32_t LMX2_R37_update_1	= 0x250104; //PFD_DLY_SEL = 1
uint32_t LMX2_R37_update	= 0x250204;
uint32_t LMX2_R75_update	= 0x4B0840;
uint32_t LMX2_R45_update	= 0x2DC0C0;
uint32_t LMX2_R27_update	= 0x1B0002;
uint32_t LMX2_R44_update	= 0x2C0080;
uint32_t LMX2_R0_reset		= 0x00259E; //OUT_MUTE = 0
uint32_t LMX2_R0			= 0x00259C; //OUT_MUTE = 0
uint32_t LMX2_R58			= 0x3A8001;
uint32_t LMX2_R0_mute		= 0x00259D;
uint32_t LMX2_register[113] = {
0x700000,
0x6F0000,
0x6E0000,
0x6D0000,
0x6C0000,
0x6B0000,
0x6A0000,
0x690021,
0x680000,
0x670000,
0x660000,
0x650011,
0x640000,
0x630000,
0x620000,
0x610888,
0x600000,
0x5F0000,
0x5E0000,
0x5D0000,
0x5C0000,
0x5B0000,
0x5A0000,
0x590000,
0x580000,
0x570000,
0x560000,
0x550000,
0x540000,
0x530000,
0x520000,
0x510000,
0x500000,
0x4F0000,
0x4E0003,
0x4D0000,
0x4C000C,
0x4B0840,
0x4A0000,
0x49003F,
0x480001,
0x470081,
0x46C350,
0x450000,
0x4403E8,
0x430000,
0x4201F4,
0x410000,
0x401388,
0x3F0000,
0x3E0322,
0x3D00A8,
0x3C0000,
0x3B0001,
0x3A8001,
0x390020,
0x380000,
0x370000,
0x360000,
0x350000,
0x340820,
0x330080,
0x320000,
0x314180,
0x300300,
0x2F0300,
0x2E07FC,
0x2DC0C0,
0x2C0080,
0x2B0000,
0x2A0000,
0x290000,
0x280000,
0x27000A,
0x260000,
0x250204, //PFD_DLY_SEL = 2
0x240030,
0x230004,
0x220000,
0x211E21,
0x200393,
0x1F43EC,
0x1E318C,
0x1D318C,
0x1C0488,
0x1B0002, // VCO Doubler is Disabled
0x1A0DB0,
0x190624,
0x18071A,
0x17007C,
0x160001,
0x150401,
0x14E048,
0x1327B7,
0x120064,
0x11012C,
0x100080,
0x0F064F,
0x0E1E40, //CP = 3mA
0x0D4000,
0x0C5001,
0x0B0018,
0x0A10D8,
0x091604, // Ref Doubler is ON
0x082000,
0x0740B2, // OUT_FORCE = 1
0x06C802,
0x0500C8,
0x040A43,
0x030642,
0x020500,
0x010808, // CAL_CLK_DIV = 0
0x00259C //OUT_MUTE = 0
};

uint32_t WBFM_LMX2_R12			= 0x0C500A;  //Pre-R = 10
uint32_t WBFM_LMX2_R11			= 0x0B0C88;  //Post-R = 200
uint32_t WBFM_LMX2_R34_update	= 0x220001;  //N = N*2000
uint32_t WBFM_LMX2_R36_update	= 0x247700;  //N = N*2000
uint32_t WBFM_LMX2_R14			= 0x0E1E40;  //CP = 3mA
uint32_t WBFM_LMX2_R0			= 0x002474; //FCAL=0, FCAL_HPF=0   FCAL_LPF=3
uint32_t WBFM_LMX2_R0_FCAL		= 0x00247C; //FCAL=1
